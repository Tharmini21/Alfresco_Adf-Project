import { AlfrescoApiService, LogService } from '@alfresco/adf-core';
import { Injectable } from '@angular/core';
import { RatingBody } from '@alfresco/js-api';
import { from, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
export class RatingService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    getRating(nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.getRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    }
    postRating(nodeId, ratingType, vote) {
        const ratingBody = new RatingBody({
            'id': ratingType,
            'myRating': vote
        });
        return from(this.apiService.getInstance().core.ratingsApi.rate(nodeId, ratingBody))
            .pipe(catchError(this.handleError));
    }
    deleteRating(nodeId, ratingType) {
        return from(this.apiService.getInstance().core.ratingsApi.removeRating(nodeId, ratingType))
            .pipe(catchError(this.handleError));
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
RatingService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RatingService_Factory() { return new RatingService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.LogService)); }, token: RatingService, providedIn: "root" });
RatingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
RatingService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF0aW5nLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb250ZW50LXNlcnZpY2VzL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9zb2NpYWwvc2VydmljZXMvcmF0aW5nLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJBLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBZSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQUs1QyxNQUFNLE9BQU8sYUFBYTtJQUV0QixZQUFvQixVQUE4QixFQUFVLFVBQXNCO1FBQTlELGVBQVUsR0FBVixVQUFVLENBQW9CO1FBQVUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtJQUNsRixDQUFDO0lBUUQsU0FBUyxDQUFDLE1BQWMsRUFBRSxVQUFlO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQ25GLElBQUksQ0FDRCxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUMvQixDQUFDO0lBQ1YsQ0FBQztJQVNELFVBQVUsQ0FBQyxNQUFjLEVBQUUsVUFBa0IsRUFBRSxJQUFTO1FBQ3BELE1BQU0sVUFBVSxHQUFlLElBQUksVUFBVSxDQUFDO1lBQzFDLElBQUksRUFBRSxVQUFVO1lBQ2hCLFVBQVUsRUFBRSxJQUFJO1NBQ25CLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQzlFLElBQUksQ0FDRCxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUMvQixDQUFDO0lBQ1YsQ0FBQztJQVFELFlBQVksQ0FBQyxNQUFjLEVBQUUsVUFBZTtRQUN4QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQzthQUN0RixJQUFJLENBQ0QsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FDL0IsQ0FBQztJQUNWLENBQUM7SUFFTyxXQUFXLENBQUMsS0FBVTtRQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM3QixPQUFPLFVBQVUsQ0FBQyxLQUFLLElBQUksY0FBYyxDQUFDLENBQUM7SUFDL0MsQ0FBQzs7OztZQXZESixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQVJRLGtCQUFrQjtZQUFFLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UsIExvZ1NlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmF0aW5nRW50cnksIFJhdGluZ0JvZHkgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IGZyb20sIHRocm93RXJyb3IsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgUmF0aW5nU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSwgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyJ3MgcmF0aW5nIGZvciBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBOb2RlIHRvIGdldCB0aGUgcmF0aW5nIGZyb21cbiAgICAgKiBAcGFyYW0gcmF0aW5nVHlwZSBUeXBlIG9mIHJhdGluZyAoY2FuIGJlIFwibGlrZXNcIiBvciBcImZpdmVTdGFyXCIpXG4gICAgICogQHJldHVybnMgVGhlIHJhdGluZyB2YWx1ZVxuICAgICAqL1xuICAgIGdldFJhdGluZyhub2RlSWQ6IHN0cmluZywgcmF0aW5nVHlwZTogYW55KTogT2JzZXJ2YWJsZTxSYXRpbmdFbnRyeSB8IHt9PiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvcmUucmF0aW5nc0FwaS5nZXRSYXRpbmcobm9kZUlkLCByYXRpbmdUeXBlKSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IodGhpcy5oYW5kbGVFcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY3VycmVudCB1c2VyJ3MgcmF0aW5nIGZvciBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBUYXJnZXQgbm9kZSBmb3IgdGhlIHJhdGluZ1xuICAgICAqIEBwYXJhbSByYXRpbmdUeXBlIFR5cGUgb2YgcmF0aW5nIChjYW4gYmUgXCJsaWtlc1wiIG9yIFwiZml2ZVN0YXJcIilcbiAgICAgKiBAcGFyYW0gdm90ZSBSYXRpbmcgdmFsdWUgKGJvb2xlYW4gZm9yIFwibGlrZXNcIiwgbnVtZXJpYyAwLi41IGZvciBcImZpdmVTdGFyXCIpXG4gICAgICogQHJldHVybnMgRGV0YWlscyBhYm91dCB0aGUgcmF0aW5nLCBpbmNsdWRpbmcgdGhlIG5ldyB2YWx1ZVxuICAgICAqL1xuICAgIHBvc3RSYXRpbmcobm9kZUlkOiBzdHJpbmcsIHJhdGluZ1R5cGU6IHN0cmluZywgdm90ZTogYW55KTogT2JzZXJ2YWJsZTxSYXRpbmdFbnRyeSB8IHt9PiB7XG4gICAgICAgIGNvbnN0IHJhdGluZ0JvZHk6IFJhdGluZ0JvZHkgPSBuZXcgUmF0aW5nQm9keSh7XG4gICAgICAgICAgICAnaWQnOiByYXRpbmdUeXBlLFxuICAgICAgICAgICAgJ215UmF0aW5nJzogdm90ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5yYXRpbmdzQXBpLnJhdGUobm9kZUlkLCByYXRpbmdCb2R5KSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGNhdGNoRXJyb3IodGhpcy5oYW5kbGVFcnJvcilcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY3VycmVudCB1c2VyJ3MgcmF0aW5nIGZvciBhIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBUYXJnZXQgbm9kZVxuICAgICAqIEBwYXJhbSByYXRpbmdUeXBlIFR5cGUgb2YgcmF0aW5nIHRvIHJlbW92ZSAoY2FuIGJlIFwibGlrZXNcIiBvciBcImZpdmVTdGFyXCIpXG4gICAgICogQHJldHVybnMgTnVsbCByZXNwb25zZSBpbmRpY2F0aW5nIHRoYXQgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZVxuICAgICAqL1xuICAgIGRlbGV0ZVJhdGluZyhub2RlSWQ6IHN0cmluZywgcmF0aW5nVHlwZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5yYXRpbmdzQXBpLnJlbW92ZVJhdGluZyhub2RlSWQsIHJhdGluZ1R5cGUpKVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcih0aGlzLmhhbmRsZUVycm9yKVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpOiBhbnkge1xuICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciB8fCAnU2VydmVyIGVycm9yJyk7XG4gICAgfVxufVxuIl19