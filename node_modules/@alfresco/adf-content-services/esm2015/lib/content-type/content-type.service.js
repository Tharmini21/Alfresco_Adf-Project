import { Injectable } from '@angular/core';
import { AlfrescoApiService } from '@alfresco/adf-core';
import { from } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class ContentTypeService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    getContentTypeByPrefix(prefixedType) {
        return from(this.alfrescoApiService.typesApi.getType(prefixedType));
    }
    getContentTypeChildren(nodeType) {
        const where = `(parentId in ('${nodeType}') and not namespaceUri matches('http://www.alfresco.*'))`;
        const opts = {
            where,
            include: ['properties']
        };
        return from(this.alfrescoApiService.typesApi.listTypes(opts)).pipe(map((result) => result.list.entries));
    }
}
ContentTypeService.ɵfac = function ContentTypeService_Factory(t) { return new (t || ContentTypeService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService)); };
ContentTypeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ContentTypeService_Factory() { return new ContentTypeService(i0.ɵɵinject(i1.AlfrescoApiService)); }, token: ContentTypeService, providedIn: "root" });
ContentTypeService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ContentTypeService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGVudC10eXBlLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb250ZW50LXNlcnZpY2VzL3NyYy9saWIvY29udGVudC10eXBlL2NvbnRlbnQtdHlwZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxJQUFJLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDeEMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDO0FBRUE7OztBQUNBLE1BQU0sT0FBTyxrQkFBa0I7QUFDL0IsSUFDSSxZQUFvQixrQkFBc0M7QUFDOUQsUUFEd0IsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtBQUFDLElBQzNELENBQUM7QUFDTCxJQUNJLHNCQUFzQixDQUFDLFlBQW9CO0FBQUksUUFDM0MsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztBQUM1RSxJQUFJLENBQUM7QUFDTCxJQUNJLHNCQUFzQixDQUFDLFFBQWdCO0FBQUksUUFDdkMsTUFBTSxLQUFLLEdBQUcsa0JBQWtCLFFBQVEsMkRBQTJELENBQUM7QUFDNUcsUUFBUSxNQUFNLElBQUksR0FBUTtBQUMxQixZQUFZLEtBQUs7QUFDakIsWUFBWSxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7QUFDbkMsU0FBUyxDQUFDO0FBQ1YsUUFBUSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDOUQsR0FBRyxDQUFDLENBQUMsTUFBa0IsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FDbkQsQ0FBQztBQUNWLElBQUksQ0FBQztBQUNMO3VKQUFDO0FBQ0QsMk5BcEJLO0FBQUM7RUFITCxVQUFVLFNBQUMsckJBS0csWUFSTixrQkFBa0I7QUFBRztHQUkxQixVQUFVLEVBQUUsTUFBTSxjQUNyQjs7Ozs7bUZBTCtCO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBUeXBlRW50cnksIFR5cGVQYWdpbmcgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIENvbnRlbnRUeXBlU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFsZnJlc2NvQXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudFR5cGVCeVByZWZpeChwcmVmaXhlZFR5cGU6IHN0cmluZyk6IE9ic2VydmFibGU8VHlwZUVudHJ5PiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuYWxmcmVzY29BcGlTZXJ2aWNlLnR5cGVzQXBpLmdldFR5cGUocHJlZml4ZWRUeXBlKSk7XG4gICAgfVxuXG4gICAgZ2V0Q29udGVudFR5cGVDaGlsZHJlbihub2RlVHlwZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUeXBlRW50cnlbXT4ge1xuICAgICAgICBjb25zdCB3aGVyZSA9IGAocGFyZW50SWQgaW4gKCcke25vZGVUeXBlfScpIGFuZCBub3QgbmFtZXNwYWNlVXJpIG1hdGNoZXMoJ2h0dHA6Ly93d3cuYWxmcmVzY28uKicpKWA7XG4gICAgICAgIGNvbnN0IG9wdHM6IGFueSA9IHtcbiAgICAgICAgICAgIHdoZXJlLFxuICAgICAgICAgICAgaW5jbHVkZTogWydwcm9wZXJ0aWVzJ11cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hbGZyZXNjb0FwaVNlcnZpY2UudHlwZXNBcGkubGlzdFR5cGVzKG9wdHMpKS5waXBlKFxuICAgICAgICAgICAgbWFwKChyZXN1bHQ6IFR5cGVQYWdpbmcpID0+IHJlc3VsdC5saXN0LmVudHJpZXMpXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19