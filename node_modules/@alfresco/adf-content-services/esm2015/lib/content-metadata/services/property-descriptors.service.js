import { Injectable } from '@angular/core';
import { AlfrescoApiService } from '@alfresco/adf-core';
import { defer, forkJoin } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class PropertyDescriptorsService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    load(groupNames) {
        const groupFetchStreams = groupNames
            .map((groupName) => groupName.replace(':', '_'))
            .map((groupName) => defer(() => this.alfrescoApiService.classesApi.getClass(groupName)));
        return forkJoin(groupFetchStreams).pipe(map(this.convertToObject));
    }
    convertToObject(propertyGroupsArray) {
        return propertyGroupsArray.reduce((propertyGroups, propertyGroup) => {
            return Object.assign({}, propertyGroups, {
                [propertyGroup.name]: propertyGroup
            });
        }, {});
    }
}
PropertyDescriptorsService.ɵfac = function PropertyDescriptorsService_Factory(t) { return new (t || PropertyDescriptorsService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService)); };
PropertyDescriptorsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PropertyDescriptorsService_Factory() { return new PropertyDescriptorsService(i0.ɵɵinject(i1.AlfrescoApiService)); }, token: PropertyDescriptorsService, providedIn: "root" });
PropertyDescriptorsService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(PropertyDescriptorsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHktZGVzY3JpcHRvcnMuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjL2xpYi9jb250ZW50LW1ldGFkYXRhL3NlcnZpY2VzL3Byb3BlcnR5LWRlc2NyaXB0b3JzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDeEQsT0FBTyxFQUFjLEtBQUssRUFBRSxRQUFRLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFbkQsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDO0FBRXNCOzs7QUFFdEIsTUFBTSxPQUFPLDBCQUEwQjtBQUN2QyxJQUNJLFlBQW9CLGtCQUFzQztBQUFJLFFBQTFDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7QUFBQyxJQUFFLENBQUM7QUFDbEUsSUFDSSxJQUFJLENBQUMsVUFBb0I7QUFBSSxRQUN6QixNQUFNLGlCQUFpQixHQUFHLFVBQVU7QUFDNUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzVELGFBQWEsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBRSxDQUFDO0FBQ3ZHLFFBQ1EsT0FBTyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxJQUFJLENBQ25DLEdBQUcsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQzVCLENBQUM7QUFDVixJQUFJLENBQUM7QUFDTCxJQUNZLGVBQWUsQ0FBQyxtQkFBb0M7QUFBSSxRQUM1RCxPQUFPLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDLGNBQWMsRUFBRSxhQUFhLEVBQUUsRUFBRTtBQUM1RSxZQUFZLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsY0FBYyxFQUFFO0FBQ3JELGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxhQUFhO0FBQ25ELGFBQWEsQ0FBQyxDQUFDO0FBQ2YsUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDZixJQUFJLENBQUM7QUFDTDsrS0FBQztBQUNELDJQQXRCSztBQUFDO0VBSEwsVUFBVSxTQUFDLHJCQUtHLFlBVk4sa0JBQWtCO0FBQUc7R0FNMUIsVUFBVSxFQUFFLE1BQU0sY0FDckI7Ozs7O21GQVArQjtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGRlZmVyLCBmb3JrSm9pbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUHJvcGVydHlHcm91cCwgUHJvcGVydHlHcm91cENvbnRhaW5lciB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29udGVudC1tZXRhZGF0YS5pbnRlcmZhY2VzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eURlc2NyaXB0b3JzU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFsZnJlc2NvQXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlKSB7fVxuXG4gICAgbG9hZChncm91cE5hbWVzOiBzdHJpbmdbXSk6IE9ic2VydmFibGU8UHJvcGVydHlHcm91cENvbnRhaW5lcj4ge1xuICAgICAgICBjb25zdCBncm91cEZldGNoU3RyZWFtcyA9IGdyb3VwTmFtZXNcbiAgICAgICAgICAgIC5tYXAoKGdyb3VwTmFtZSkgPT4gZ3JvdXBOYW1lLnJlcGxhY2UoJzonLCAnXycpKVxuICAgICAgICAgICAgLm1hcCgoZ3JvdXBOYW1lKSA9PiBkZWZlciggKCkgPT4gdGhpcy5hbGZyZXNjb0FwaVNlcnZpY2UuY2xhc3Nlc0FwaS5nZXRDbGFzcyhncm91cE5hbWUpKSApO1xuXG4gICAgICAgIHJldHVybiBmb3JrSm9pbihncm91cEZldGNoU3RyZWFtcykucGlwZShcbiAgICAgICAgICAgIG1hcCh0aGlzLmNvbnZlcnRUb09iamVjdClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnZlcnRUb09iamVjdChwcm9wZXJ0eUdyb3Vwc0FycmF5OiBQcm9wZXJ0eUdyb3VwW10pOiBQcm9wZXJ0eUdyb3VwQ29udGFpbmVyIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXBzQXJyYXkucmVkdWNlKChwcm9wZXJ0eUdyb3VwcywgcHJvcGVydHlHcm91cCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByb3BlcnR5R3JvdXBzLCB7XG4gICAgICAgICAgICAgICAgW3Byb3BlcnR5R3JvdXAubmFtZV06IHByb3BlcnR5R3JvdXBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxufVxuIl19