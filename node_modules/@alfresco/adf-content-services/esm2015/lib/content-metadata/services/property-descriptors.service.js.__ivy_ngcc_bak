import { Injectable } from '@angular/core';
import { AlfrescoApiService } from '@alfresco/adf-core';
import { defer, forkJoin } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
export class PropertyDescriptorsService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    load(groupNames) {
        const groupFetchStreams = groupNames
            .map((groupName) => groupName.replace(':', '_'))
            .map((groupName) => defer(() => this.alfrescoApiService.classesApi.getClass(groupName)));
        return forkJoin(groupFetchStreams).pipe(map(this.convertToObject));
    }
    convertToObject(propertyGroupsArray) {
        return propertyGroupsArray.reduce((propertyGroups, propertyGroup) => {
            return Object.assign({}, propertyGroups, {
                [propertyGroup.name]: propertyGroup
            });
        }, {});
    }
}
PropertyDescriptorsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PropertyDescriptorsService_Factory() { return new PropertyDescriptorsService(i0.ɵɵinject(i1.AlfrescoApiService)); }, token: PropertyDescriptorsService, providedIn: "root" });
PropertyDescriptorsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PropertyDescriptorsService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydHktZGVzY3JpcHRvcnMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjLyIsInNvdXJjZXMiOlsibGliL2NvbnRlbnQtbWV0YWRhdGEvc2VydmljZXMvcHJvcGVydHktZGVzY3JpcHRvcnMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN4RCxPQUFPLEVBQWMsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVuRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQUtyQyxNQUFNLE9BQU8sMEJBQTBCO0lBRW5DLFlBQW9CLGtCQUFzQztRQUF0Qyx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO0lBQUcsQ0FBQztJQUU5RCxJQUFJLENBQUMsVUFBb0I7UUFDckIsTUFBTSxpQkFBaUIsR0FBRyxVQUFVO2FBQy9CLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDL0MsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBRSxDQUFDO1FBRS9GLE9BQU8sUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUMsSUFBSSxDQUNuQyxHQUFHLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUM1QixDQUFDO0lBQ04sQ0FBQztJQUVPLGVBQWUsQ0FBQyxtQkFBb0M7UUFDeEQsT0FBTyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLEVBQUU7WUFDaEUsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxjQUFjLEVBQUU7Z0JBQ3JDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLGFBQWE7YUFDdEMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ1gsQ0FBQzs7OztZQXZCSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQVBRLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBkZWZlciwgZm9ya0pvaW4gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFByb3BlcnR5R3JvdXAsIFByb3BlcnR5R3JvdXBDb250YWluZXIgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbnRlbnQtbWV0YWRhdGEuaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgUHJvcGVydHlEZXNjcmlwdG9yc1NlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhbGZyZXNjb0FwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSkge31cblxuICAgIGxvYWQoZ3JvdXBOYW1lczogc3RyaW5nW10pOiBPYnNlcnZhYmxlPFByb3BlcnR5R3JvdXBDb250YWluZXI+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBGZXRjaFN0cmVhbXMgPSBncm91cE5hbWVzXG4gICAgICAgICAgICAubWFwKChncm91cE5hbWUpID0+IGdyb3VwTmFtZS5yZXBsYWNlKCc6JywgJ18nKSlcbiAgICAgICAgICAgIC5tYXAoKGdyb3VwTmFtZSkgPT4gZGVmZXIoICgpID0+IHRoaXMuYWxmcmVzY29BcGlTZXJ2aWNlLmNsYXNzZXNBcGkuZ2V0Q2xhc3MoZ3JvdXBOYW1lKSkgKTtcblxuICAgICAgICByZXR1cm4gZm9ya0pvaW4oZ3JvdXBGZXRjaFN0cmVhbXMpLnBpcGUoXG4gICAgICAgICAgICBtYXAodGhpcy5jb252ZXJ0VG9PYmplY3QpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb252ZXJ0VG9PYmplY3QocHJvcGVydHlHcm91cHNBcnJheTogUHJvcGVydHlHcm91cFtdKTogUHJvcGVydHlHcm91cENvbnRhaW5lciB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3Vwc0FycmF5LnJlZHVjZSgocHJvcGVydHlHcm91cHMsIHByb3BlcnR5R3JvdXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wZXJ0eUdyb3Vwcywge1xuICAgICAgICAgICAgICAgIFtwcm9wZXJ0eUdyb3VwLm5hbWVdOiBwcm9wZXJ0eUdyb3VwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbn1cbiJdfQ==