import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { AlfrescoApiService } from '@alfresco/adf-core';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class GroupService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    listAllGroupMembershipsForPerson(personId, opts, accumulator = []) {
        return __awaiter(this, void 0, void 0, function* () {
            const groupsPaginated = yield this.alfrescoApiService.groupsApi.listGroupMembershipsForPerson(personId, opts);
            accumulator = [...accumulator, ...groupsPaginated.list.entries];
            if (groupsPaginated.list.pagination.hasMoreItems) {
                const skip = groupsPaginated.list.pagination.skipCount + groupsPaginated.list.pagination.count;
                return this.listAllGroupMembershipsForPerson(personId, {
                    maxItems: opts.maxItems,
                    skipCount: skip
                }, accumulator);
            }
            else {
                return accumulator;
            }
        });
    }
}
GroupService.ɵfac = function GroupService_Factory(t) { return new (t || GroupService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService)); };
GroupService.ɵprov = i0.ɵɵdefineInjectable({ factory: function GroupService_Factory() { return new GroupService(i0.ɵɵinject(i1.AlfrescoApiService)); }, token: GroupService, providedIn: "root" });
GroupService.ctorParameters = () => [
    { type: AlfrescoApiService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(GroupService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JvdXAuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjL2xpYi9ncm91cC9zZXJ2aWNlcy9ncm91cC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFpQkEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUN4RDtBQUVzQjs7O0FBRXRCLE1BQU0sT0FBTyxZQUFZO0FBQ3pCLElBQUksWUFDWSxrQkFBc0M7QUFDbkQsUUFEYSx1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW9CO0FBQ3RELElBQU8sQ0FBQztBQUNSLElBQ1UsZ0NBQWdDLENBQUMsUUFBZ0IsRUFBRSxJQUFVLEVBQUUsV0FBVyxHQUFHLEVBQUU7QUFBSTtBQUN0RCxZQUEvQixNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsNkJBQTZCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3RILFlBQVEsV0FBVyxHQUFHLENBQUMsR0FBRyxXQUFXLEVBQUUsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3hFLFlBQVEsSUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUU7QUFDMUQsZ0JBQVksTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztBQUMzRyxnQkFBWSxPQUFPLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxRQUFRLEVBQUU7QUFDbkUsb0JBQWdCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUTtBQUN2QyxvQkFBZ0IsU0FBUyxFQUFFLElBQUk7QUFDL0IsaUJBQWEsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUM1QixhQUFTO0FBQUMsaUJBQUs7QUFDZixnQkFBWSxPQUFPLFdBQVcsQ0FBQztBQUMvQixhQUFTO0FBQ1QsUUFBSSxDQUFDO0FBRUwsS0FGSztBQUNMO3FJQUFDO0FBQ0QsbU1BbkJLO0FBQUM7RUFITCxVQUFVLFNBQUMsckJBSUksWUFOUCxrQkFBa0I7QUFBRztHQUcxQixVQUFVLEVBQUUsTUFBTSxjQUNyQjs7Ozs7bUZBSitCO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHcm91cEVudHJ5IH0gZnJvbSAnQGFsZnJlc2NvL2pzLWFwaSc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEdyb3VwU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgYWxmcmVzY29BcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2VcbiAgICApIHt9XG5cbiAgICBhc3luYyBsaXN0QWxsR3JvdXBNZW1iZXJzaGlwc0ZvclBlcnNvbihwZXJzb25JZDogc3RyaW5nLCBvcHRzPzogYW55LCBhY2N1bXVsYXRvciA9IFtdKTogUHJvbWlzZTxHcm91cEVudHJ5W10+IHtcbiAgICAgICAgY29uc3QgZ3JvdXBzUGFnaW5hdGVkID0gYXdhaXQgdGhpcy5hbGZyZXNjb0FwaVNlcnZpY2UuZ3JvdXBzQXBpLmxpc3RHcm91cE1lbWJlcnNoaXBzRm9yUGVyc29uKHBlcnNvbklkLCBvcHRzKTtcbiAgICAgICAgYWNjdW11bGF0b3IgPSBbLi4uYWNjdW11bGF0b3IsIC4uLmdyb3Vwc1BhZ2luYXRlZC5saXN0LmVudHJpZXNdO1xuICAgICAgICBpZiAoZ3JvdXBzUGFnaW5hdGVkLmxpc3QucGFnaW5hdGlvbi5oYXNNb3JlSXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNraXAgPSBncm91cHNQYWdpbmF0ZWQubGlzdC5wYWdpbmF0aW9uLnNraXBDb3VudCArIGdyb3Vwc1BhZ2luYXRlZC5saXN0LnBhZ2luYXRpb24uY291bnQ7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saXN0QWxsR3JvdXBNZW1iZXJzaGlwc0ZvclBlcnNvbihwZXJzb25JZCwge1xuICAgICAgICAgICAgICAgIG1heEl0ZW1zOiBvcHRzLm1heEl0ZW1zLFxuICAgICAgICAgICAgICAgIHNraXBDb3VudDogc2tpcFxuICAgICAgICAgICAgfSwgYWNjdW11bGF0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19