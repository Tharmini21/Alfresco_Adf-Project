import { Injectable } from '@angular/core';
import { from, throwError } from 'rxjs';
import { LogService } from './log.service';
import { AlfrescoApiService } from './alfresco-api.service';
import { catchError } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./alfresco-api.service";
import * as i2 from "./log.service";
export class DownloadZipService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    createDownload(payload) {
        return from(this.apiService.getInstance().core.downloadsApi.createDownload(payload)).pipe(catchError((err) => this.handleError(err)));
    }
    getContentUrl(nodeId, attachment) {
        return this.apiService.getInstance().content.getContentUrl(nodeId, attachment);
    }
    getNode(nodeId) {
        return from(this.apiService.getInstance().core.nodesApi.getNode(nodeId));
    }
    getDownload(downloadId) {
        return from(this.apiService.getInstance().core.downloadsApi.getDownload(downloadId));
    }
    cancelDownload(downloadId) {
        this.apiService.getInstance().core.downloadsApi.cancelDownload(downloadId);
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DownloadZipService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DownloadZipService_Factory() { return new DownloadZipService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i2.LogService)); }, token: DownloadZipService, providedIn: "root" });
DownloadZipService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DownloadZipService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG93bmxvYWQtemlwLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb3JlLyIsInNvdXJjZXMiOlsic2VydmljZXMvZG93bmxvYWQtemlwLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBa0JBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFjLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDcEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7QUFLNUMsTUFBTSxPQUFPLGtCQUFrQjtJQUUzQixZQUFvQixVQUE4QixFQUM5QixVQUFzQjtRQUR0QixlQUFVLEdBQVYsVUFBVSxDQUFvQjtRQUM5QixlQUFVLEdBQVYsVUFBVSxDQUFZO0lBQzFDLENBQUM7SUFPRCxjQUFjLENBQUMsT0FBMkI7UUFDdEMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDckYsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQzdDLENBQUM7SUFDTixDQUFDO0lBUUQsYUFBYSxDQUFDLE1BQWMsRUFBRSxVQUFvQjtRQUM5QyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDbkYsQ0FBQztJQU9ELE9BQU8sQ0FBQyxNQUFjO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBT0QsV0FBVyxDQUFDLFVBQWtCO1FBQzFCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUN6RixDQUFDO0lBTUQsY0FBYyxDQUFDLFVBQWtCO1FBQzdCLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVPLFdBQVcsQ0FBQyxLQUFVO1FBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzdCLE9BQU8sVUFBVSxDQUFDLEtBQUssSUFBSSxjQUFjLENBQUMsQ0FBQztJQUMvQyxDQUFDOzs7O1lBM0RKLFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQjs7O1lBTFEsa0JBQWtCO1lBRGxCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBOb2RlRW50cnksIERvd25sb2FkRW50cnksIERvd25sb2FkQm9keUNyZWF0ZSB9IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4vbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi9hbGZyZXNjby1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIERvd25sb2FkWmlwU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGRvd25sb2FkLlxuICAgICAqIEBwYXJhbSBwYXlsb2FkIE9iamVjdCBjb250YWluaW5nIHRoZSBub2RlIElEcyBvZiB0aGUgaXRlbXMgdG8gYWRkIHRvIHRoZSBaSVAgZmlsZVxuICAgICAqIEByZXR1cm5zIFN0YXR1cyBvYmplY3QgZm9yIHRoZSBkb3dubG9hZFxuICAgICAqL1xuICAgIGNyZWF0ZURvd25sb2FkKHBheWxvYWQ6IERvd25sb2FkQm9keUNyZWF0ZSk6IE9ic2VydmFibGU8RG93bmxvYWRFbnRyeT4ge1xuICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKS5jb3JlLmRvd25sb2Fkc0FwaS5jcmVhdGVEb3dubG9hZChwYXlsb2FkKSkucGlwZShcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb250ZW50IFVSTCBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gICAgICogQHBhcmFtIG5vZGVJZCBOb2RlIHRvIGdldCBVUkwgZm9yLlxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50IFRvZ2dsZXMgd2hldGhlciB0byByZXRyaWV2ZSBjb250ZW50IGFzIGFuIGF0dGFjaG1lbnQgZm9yIGRvd25sb2FkXG4gICAgICogQHJldHVybnMgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGdldENvbnRlbnRVcmwobm9kZUlkOiBzdHJpbmcsIGF0dGFjaG1lbnQ/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpLmNvbnRlbnQuZ2V0Q29udGVudFVybChub2RlSWQsIGF0dGFjaG1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBOb2RlIHZpYSBpdHMgbm9kZSBJRC5cbiAgICAgKiBAcGFyYW0gbm9kZUlkIElEIG9mIHRoZSB0YXJnZXQgbm9kZVxuICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIG5vZGVcbiAgICAgKi9cbiAgICBnZXROb2RlKG5vZGVJZDogc3RyaW5nKTogT2JzZXJ2YWJsZTxOb2RlRW50cnk+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5ub2Rlc0FwaS5nZXROb2RlKG5vZGVJZCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgc3RhdHVzIGluZm9ybWF0aW9uIGZvciBhIGRvd25sb2FkIG5vZGUuXG4gICAgICogQHBhcmFtIGRvd25sb2FkSWQgSUQgb2YgdGhlIGRvd25sb2FkIG5vZGVcbiAgICAgKiBAcmV0dXJucyBTdGF0dXMgb2JqZWN0IGZvciB0aGUgZG93bmxvYWRcbiAgICAgKi9cbiAgICBnZXREb3dubG9hZChkb3dubG9hZElkOiBzdHJpbmcpOiBPYnNlcnZhYmxlPERvd25sb2FkRW50cnk+IHtcbiAgICAgICAgcmV0dXJuIGZyb20odGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5kb3dubG9hZHNBcGkuZ2V0RG93bmxvYWQoZG93bmxvYWRJZCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYSBkb3dubG9hZC5cbiAgICAgKiBAcGFyYW0gZG93bmxvYWRJZCBJRCBvZiB0aGUgdGFyZ2V0IGRvd25sb2FkIG5vZGVcbiAgICAgKi9cbiAgICBjYW5jZWxEb3dubG9hZChkb3dubG9hZElkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkuY29yZS5kb3dubG9hZHNBcGkuY2FuY2VsRG93bmxvYWQoZG93bmxvYWRJZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcihlcnJvcik7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIHx8ICdTZXJ2ZXIgZXJyb3InKTtcbiAgICB9XG59XG4iXX0=