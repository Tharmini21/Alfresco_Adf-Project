/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
export let fakeSearch = {
    list: {
        pagination: {
            count: 1,
            hasMoreItems: false,
            totalItems: 1,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: '123',
                    name: 'MyDoc',
                    content: {
                        mimetype: 'text/plain'
                    },
                    createdByUser: {
                        displayName: 'John Doe'
                    },
                    modifiedByUser: {
                        displayName: 'John Doe'
                    }
                }
            }
        ]
    }
};
export let mockError = {
    error: {
        errorKey: 'Search failed',
        statusCode: 400,
        briefSummary: '08220082 search failed',
        stackTrace: 'For security reasons the stack trace is no longer displayed, but the property is kept for previous versions.',
        descriptionURL: 'https://api-explorer.alfresco.com'
    }
};
const ɵ0 = () => Promise.resolve(fakeSearch), ɵ1 = () => '';
export let searchMockApi = {
    core: {
        queriesApi: {
            findNodes: ɵ0
        }
    },
    isEcmLoggedIn() {
        return false;
    },
    reply: ɵ1
};
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLnNlcnZpY2UubW9jay5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvcmUvIiwic291cmNlcyI6WyJtb2NrL3NlYXJjaC5zZXJ2aWNlLm1vY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsTUFBTSxDQUFDLElBQUksVUFBVSxHQUFHO0lBQ3BCLElBQUksRUFBRTtRQUNGLFVBQVUsRUFBRTtZQUNSLEtBQUssRUFBRSxDQUFDO1lBQ1IsWUFBWSxFQUFFLEtBQUs7WUFDbkIsVUFBVSxFQUFFLENBQUM7WUFDYixTQUFTLEVBQUUsQ0FBQztZQUNaLFFBQVEsRUFBRSxHQUFHO1NBQ2hCO1FBQ0QsT0FBTyxFQUFFO1lBQ0w7Z0JBQ0ksS0FBSyxFQUFFO29CQUNILEVBQUUsRUFBRSxLQUFLO29CQUNULElBQUksRUFBRSxPQUFPO29CQUNiLE9BQU8sRUFBRTt3QkFDTCxRQUFRLEVBQUUsWUFBWTtxQkFDekI7b0JBQ0QsYUFBYSxFQUFFO3dCQUNYLFdBQVcsRUFBRSxVQUFVO3FCQUMxQjtvQkFDRCxjQUFjLEVBQUU7d0JBQ1osV0FBVyxFQUFFLFVBQVU7cUJBQzFCO2lCQUNKO2FBQ0o7U0FDSjtLQUNKO0NBQ0osQ0FBQztBQUVGLE1BQU0sQ0FBQyxJQUFJLFNBQVMsR0FBRztJQUNuQixLQUFLLEVBQUU7UUFDSCxRQUFRLEVBQUUsZUFBZTtRQUN6QixVQUFVLEVBQUUsR0FBRztRQUNmLFlBQVksRUFBRSx3QkFBd0I7UUFDdEMsVUFBVSxFQUFFLDhHQUE4RztRQUMxSCxjQUFjLEVBQUUsbUNBQW1DO0tBQ3REO0NBQ0osQ0FBQztXQUtxQixHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQU03QyxHQUFHLEVBQUUsQ0FBQyxFQUFFO0FBVG5CLE1BQU0sQ0FBQyxJQUFJLGFBQWEsR0FBUTtJQUM1QixJQUFJLEVBQUU7UUFDRixVQUFVLEVBQUU7WUFDUixTQUFTLElBQW1DO1NBQy9DO0tBQ0o7SUFDRCxhQUFhO1FBQ1QsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUNELEtBQUssSUFBVTtDQUNsQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGxldCBmYWtlU2VhcmNoID0ge1xuICAgIGxpc3Q6IHtcbiAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICBoYXNNb3JlSXRlbXM6IGZhbHNlLFxuICAgICAgICAgICAgdG90YWxJdGVtczogMSxcbiAgICAgICAgICAgIHNraXBDb3VudDogMCxcbiAgICAgICAgICAgIG1heEl0ZW1zOiAxMDBcbiAgICAgICAgfSxcbiAgICAgICAgZW50cmllczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVudHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ015RG9jJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWltZXR5cGU6ICd0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVkQnlVc2VyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogJ0pvaG4gRG9lJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEJ5VXNlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6ICdKb2huIERvZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH1cbn07XG5cbmV4cG9ydCBsZXQgbW9ja0Vycm9yID0ge1xuICAgIGVycm9yOiB7XG4gICAgICAgIGVycm9yS2V5OiAnU2VhcmNoIGZhaWxlZCcsXG4gICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgYnJpZWZTdW1tYXJ5OiAnMDgyMjAwODIgc2VhcmNoIGZhaWxlZCcsXG4gICAgICAgIHN0YWNrVHJhY2U6ICdGb3Igc2VjdXJpdHkgcmVhc29ucyB0aGUgc3RhY2sgdHJhY2UgaXMgbm8gbG9uZ2VyIGRpc3BsYXllZCwgYnV0IHRoZSBwcm9wZXJ0eSBpcyBrZXB0IGZvciBwcmV2aW91cyB2ZXJzaW9ucy4nLFxuICAgICAgICBkZXNjcmlwdGlvblVSTDogJ2h0dHBzOi8vYXBpLWV4cGxvcmVyLmFsZnJlc2NvLmNvbSdcbiAgICB9XG59O1xuXG5leHBvcnQgbGV0IHNlYXJjaE1vY2tBcGk6IGFueSA9IHtcbiAgICBjb3JlOiB7XG4gICAgICAgIHF1ZXJpZXNBcGk6IHtcbiAgICAgICAgICAgIGZpbmROb2RlczogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKGZha2VTZWFyY2gpXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGlzRWNtTG9nZ2VkSW4oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlcGx5OiAoKSA9PiAnJ1xufTtcbiJdfQ==