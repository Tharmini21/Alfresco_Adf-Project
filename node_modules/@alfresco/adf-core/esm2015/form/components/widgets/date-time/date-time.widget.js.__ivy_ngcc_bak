/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material/core';
import { DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import { MomentDatetimeAdapter, MAT_MOMENT_DATETIME_FORMATS } from '@mat-datetimepicker/moment';
import moment from 'moment-es6';
import { UserPreferencesService, UserPreferenceValues } from '../../../../services/user-preferences.service';
import { MomentDateAdapter } from '../../../../utils/moment-date-adapter';
import { MOMENT_DATE_FORMATS } from '../../../../utils/moment-date-formats.model';
import { FormService } from './../../../services/form.service';
import { WidgetComponent } from './../widget.component';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
const ɵ0 = MOMENT_DATE_FORMATS, ɵ1 = MAT_MOMENT_DATETIME_FORMATS;
export class DateTimeWidgetComponent extends WidgetComponent {
    constructor(formService, dateAdapter, userPreferencesService) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
        }
        this.displayDate = moment(this.field.value, this.field.dateDisplayFormat)
            .add(moment(this.field.value, this.field.dateDisplayFormat).utcOffset(), 'minutes');
    }
    ngOnChanges(changes) {
        if (changes && changes.field && !changes.field.firstChange && changes.field.currentValue.value !== changes.field.previousValue.value) {
            this.displayDate = moment(changes.field.currentValue.value, this.field.dateDisplayFormat)
                .add(moment(changes.field.currentValue.value, this.field.dateDisplayFormat).utcOffset(), 'minutes');
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            this.field.value = newDateValue.value.format(this.field.dateDisplayFormat);
        }
        else if (newDateValue) {
            this.field.value = newDateValue;
        }
        else {
            this.field.value = null;
        }
        this.onFieldChanged(this.field);
    }
}
DateTimeWidgetComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1 }
                ],
                selector: 'date-time-widget',
                template: "<div class=\"{{field.className}}\" id=\"data-time-widget\" [class.adf-invalid]=\"!field.isValid\">\n    <mat-form-field class=\"adf-date-time-widget\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }} ({{field.dateDisplayFormat}})<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               [matDatetimepicker]=\"datetimePicker\"\n               [id]=\"field.id\"\n               [(ngModel)]=\"displayDate\"\n               [required]=\"isRequired()\"\n               [disabled]=\"field.readOnly\"\n               [min]=\"minDate\"\n               [max]=\"maxDate\"\n               (focusout)=\"onDateChanged($any($event).srcElement.value)\"\n               (dateChange)=\"onDateChanged($event)\"\n               [placeholder]=\"field.placeholder\"\n               [matTooltip]=\"field.tooltip\"\n               matTooltipPosition=\"above\"\n               matTooltipShowDelay=\"1000\">\n        <mat-datetimepicker-toggle matSuffix [for]=\"datetimePicker\" [disabled]=\"field.readOnly\"></mat-datetimepicker-toggle>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    <mat-datetimepicker #datetimePicker type=\"datetime\" [openOnFocus]=\"true\" [timeInterval]=\"5\"></mat-datetimepicker>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-date-time-widget .mat-form-field-suffix{top:26px}.adf-date-time-widget .mat-form-field-label-wrapper{top:20px}"]
            },] }
];
DateTimeWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLndpZGdldC5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvcmUvIiwic291cmNlcyI6WyJmb3JtL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRlLXRpbWUvZGF0ZS10aW1lLndpZGdldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxPQUFPLEVBQUUsU0FBUyxFQUFVLGlCQUFpQixFQUF1QyxNQUFNLGVBQWUsQ0FBQztBQUMxRyxPQUFPLEVBQUUsV0FBVyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDdkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSwyQkFBMkIsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ2hHLE9BQU8sTUFBTSxNQUFNLFlBQVksQ0FBQztBQUVoQyxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwrQ0FBK0MsQ0FBQztBQUM3RyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUMxRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSw2Q0FBNkMsQ0FBQztBQUNsRixPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDL0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO1dBS0ksbUJBQW1CLE9BRWYsMkJBQTJCO0FBTzlFLE1BQU0sT0FBTyx1QkFBd0IsU0FBUSxlQUFlO0lBUXhELFlBQW1CLFdBQXdCLEVBQ3ZCLFdBQWdDLEVBQ2hDLHNCQUE4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O1lBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1NBQzNCO1FBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQzs7O1lBdkVKLFNBQVMsU0FBQztnQkFDUCxTQUFTLEVBQUU7b0JBQ1AsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRTtvQkFDckQsRUFBRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxJQUFxQixFQUFFO29CQUM1RCxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLHFCQUFxQixFQUFFO29CQUM3RCxFQUFFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxRQUFRLElBQTZCLEVBQUU7aUJBQzNFO2dCQUNELFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLHE2Q0FBc0M7Z0JBRXRDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJOzthQUN4Qzs7O1lBaEJRLFdBQVc7WUFSWCxXQUFXO1lBS1gsc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgVmlld0VuY2Fwc3VsYXRpb24sIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlQWRhcHRlciwgTUFUX0RBVEVfRk9STUFUUyB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZXRpbWVBZGFwdGVyLCBNQVRfREFURVRJTUVfRk9STUFUUyB9IGZyb20gJ0BtYXQtZGF0ZXRpbWVwaWNrZXIvY29yZSc7XG5pbXBvcnQgeyBNb21lbnREYXRldGltZUFkYXB0ZXIsIE1BVF9NT01FTlRfREFURVRJTUVfRk9STUFUUyB9IGZyb20gJ0BtYXQtZGF0ZXRpbWVwaWNrZXIvbW9tZW50JztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50LWVzNic7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgVXNlclByZWZlcmVuY2VzU2VydmljZSwgVXNlclByZWZlcmVuY2VWYWx1ZXMgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXJ2aWNlcy91c2VyLXByZWZlcmVuY2VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTW9tZW50RGF0ZUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9tb21lbnQtZGF0ZS1hZGFwdGVyJztcbmltcG9ydCB7IE1PTUVOVF9EQVRFX0ZPUk1BVFMgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9tb21lbnQtZGF0ZS1mb3JtYXRzLm1vZGVsJztcbmltcG9ydCB7IEZvcm1TZXJ2aWNlIH0gZnJvbSAnLi8uLi8uLi8uLi9zZXJ2aWNlcy9mb3JtLnNlcnZpY2UnO1xuaW1wb3J0IHsgV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi8uLi93aWRnZXQuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlciB9LFxuICAgICAgICB7IHByb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNT01FTlRfREFURV9GT1JNQVRTIH0sXG4gICAgICAgIHsgcHJvdmlkZTogRGF0ZXRpbWVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50RGF0ZXRpbWVBZGFwdGVyIH0sXG4gICAgICAgIHsgcHJvdmlkZTogTUFUX0RBVEVUSU1FX0ZPUk1BVFMsIHVzZVZhbHVlOiBNQVRfTU9NRU5UX0RBVEVUSU1FX0ZPUk1BVFMgfVxuICAgIF0sXG4gICAgc2VsZWN0b3I6ICdkYXRlLXRpbWUtd2lkZ2V0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS10aW1lLndpZGdldC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9kYXRlLXRpbWUud2lkZ2V0LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIERhdGVUaW1lV2lkZ2V0Q29tcG9uZW50IGV4dGVuZHMgV2lkZ2V0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcyB7XG5cbiAgICBtaW5EYXRlOiBNb21lbnQ7XG4gICAgbWF4RGF0ZTogTW9tZW50O1xuICAgIGRpc3BsYXlEYXRlOiBNb21lbnQ7XG5cbiAgICBwcml2YXRlIG9uRGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGZvcm1TZXJ2aWNlOiBGb3JtU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxNb21lbnQ+LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgICAgICBzdXBlcihmb3JtU2VydmljZSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZVxuICAgICAgICAgICAgLnNlbGVjdChVc2VyUHJlZmVyZW5jZVZhbHVlcy5Mb2NhbGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUobG9jYWxlID0+IHRoaXMuZGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKGxvY2FsZSkpO1xuXG4gICAgICAgIGNvbnN0IG1vbWVudERhdGVBZGFwdGVyID0gPE1vbWVudERhdGVBZGFwdGVyPiB0aGlzLmRhdGVBZGFwdGVyO1xuICAgICAgICBtb21lbnREYXRlQWRhcHRlci5vdmVycmlkZURpc3BsYXlGb3JtYXQgPSB0aGlzLmZpZWxkLmRhdGVEaXNwbGF5Rm9ybWF0O1xuXG4gICAgICAgIGlmICh0aGlzLmZpZWxkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5maWVsZC5taW5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluRGF0ZSA9IG1vbWVudCh0aGlzLmZpZWxkLm1pblZhbHVlLCAnWVlZWS1NTS1ERFRISDptbTpzc1onKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZmllbGQubWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heERhdGUgPSBtb21lbnQodGhpcy5maWVsZC5tYXhWYWx1ZSwgJ1lZWVktTU0tRERUSEg6bW06c3NaJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwbGF5RGF0ZSA9IG1vbWVudCh0aGlzLmZpZWxkLnZhbHVlLCB0aGlzLmZpZWxkLmRhdGVEaXNwbGF5Rm9ybWF0KVxuICAgICAgICAgICAgLmFkZChcbiAgICAgICAgICAgICAgICBtb21lbnQodGhpcy5maWVsZC52YWx1ZSwgdGhpcy5maWVsZC5kYXRlRGlzcGxheUZvcm1hdCkudXRjT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgJ21pbnV0ZXMnKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzICYmIGNoYW5nZXMuZmllbGQgICYmICFjaGFuZ2VzLmZpZWxkLmZpcnN0Q2hhbmdlICYmIGNoYW5nZXMuZmllbGQuY3VycmVudFZhbHVlLnZhbHVlICE9PSBjaGFuZ2VzLmZpZWxkLnByZXZpb3VzVmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheURhdGUgPSBtb21lbnQoY2hhbmdlcy5maWVsZC5jdXJyZW50VmFsdWUudmFsdWUsIHRoaXMuZmllbGQuZGF0ZURpc3BsYXlGb3JtYXQpXG4gICAgICAgICAgICAgICAgLmFkZChtb21lbnQoY2hhbmdlcy5maWVsZC5jdXJyZW50VmFsdWUudmFsdWUsIHRoaXMuZmllbGQuZGF0ZURpc3BsYXlGb3JtYXQpLnV0Y09mZnNldCgpLCAnbWludXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvbkRhdGVDaGFuZ2VkKG5ld0RhdGVWYWx1ZSkge1xuICAgICAgICBpZiAobmV3RGF0ZVZhbHVlICYmIG5ld0RhdGVWYWx1ZS52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5maWVsZC52YWx1ZSA9IG5ld0RhdGVWYWx1ZS52YWx1ZS5mb3JtYXQodGhpcy5maWVsZC5kYXRlRGlzcGxheUZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmV3RGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkLnZhbHVlID0gbmV3RGF0ZVZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maWVsZC52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkZpZWxkQ2hhbmdlZCh0aGlzLmZpZWxkKTtcbiAgICB9XG5cbn1cbiJdfQ==